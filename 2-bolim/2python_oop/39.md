# üìö Darsning mavzusi: Polimorfizmni chuqurlashtirish: Duck Typing va Interface-based programming

## Qisqacha vaqt taqsimoti

| Qism                          | Davomiyligi     |
|-------------------------------|-----------------|
| Kirish va Polimorfizm qayta ko‚Äòrib chiqish | 20 daqiqa       |
| Duck Typing bilan ishlash     | 25 daqiqa       |
| Interface-based programming   | 20 daqiqa       |
| Amaliy mashqlar               | 25 daqiqa       |
| Xulosa va uy vazifasi         | 20 daqiqa       |
| Qayta aloqa va savollar       | 10 daqiqa       |
| Jami                          | 120 daqiqa (2 soat) |

Bu usul yoshlar uchun samarali, qiziqarli va tushunarli bo‚Äòlib, o‚Äòquvchilarni dars jarayoniga faolroq jalb qiladi.

---

# üìñ Darsning batafsil rejasi

## 1. Kirish va Polimorfizm qayta ko‚Äòrib chiqish (20 daqiqa)

Assalomu alaykum, yosh dasturchilar! üòä Bugun biz Python‚Äôda OOP (Obyektga yo‚Äònaltirilgan dasturlash) doirasida polimorfizmni chuqurlashtiramiz. Avvalgi darsda method overriding va method overloading (simulyatsiyasi) bilan tanishgan edik. Bugun esa polimorfizmning boshqa jihatlarini, ya‚Äôni **Duck Typing** va **Interface-based programming**ni o‚Äòrganamiz.

**Polimorfizm nima edi?**  
Polimorfizm ‚Äî bu bir xil nomli metodlarning turli sinflarda turli xil xatti-harakatlar ko‚Äòrsatishi. Bugun biz:  
- **Duck Typing**: Python‚Äôning dinamik tiplari tufayli obyektning turiga emas, uning xatti-harakatlariga e‚Äôtibor berishni o‚Äòrganamiz.  
- **Interface-based programming**: Interfeyslar orqali umumiy xatti-harakatni aniqlashni ko‚Äòramiz (Python‚Äôda bu abstract classlar orqali simulyatsiya qilinadi).  

Oddiy misol bilan boshlaymiz:

```python
class Mushuk:
    def ovoz_chiqar(self):
        return "Miyov!"

class It:
    def ovoz_chiqar(self):
        return "Vov!"

def hayvon_ovozi(hayvon):
    print(hayvon.ovoz_chiqar())

mushuk = Mushuk()
it = It()
hayvon_ovozi(mushuk)  # Miyov!
hayvon_ovozi(it)  # Vov!
```

Bu polimorfizmning oddiy shakli edi. Endi chuqurroq kiramiz!

Keling, bir savol: Polimorfizm qanday afzalliklarga ega deb o‚Äòylaysiz? (O‚Äòquvchilar javobini kutaman, to‚Äòg‚Äòri javob bo‚Äòlsa: ‚ÄúAjoyib, to‚Äòg‚Äòri!‚Äù deyman.)

Mashq: Quyidagi vazifani bajaring:  
- `Transport` nomli sinf yarating, u `harakatlan` metodiga ega bo‚Äòlsin.  
- `Mashina` nomli boshqa sinf yarating, u ham `harakatlan` metodiga ega bo‚Äòlsin.  
- `transport_harakat` nomli funksiya yozing va ikkala sinf obyektini sinab ko‚Äòring.  

5 daqiqa vaqt beraman!

---

## 2. Duck Typing bilan ishlash (25 daqiqa)

Endi **Duck Typing** bilan tanishamiz! Duck Typing ‚Äî Python‚Äôning dinamik tiplarga asoslangan xususiyati bo‚Äòlib, "Agar u o‚Äòrdak kabi yursa va o‚Äòrdak kabi qichqirsa, demak u o‚Äòrdakdir" degan tamoyilga asoslanadi.

### Duck Typing nima?
Duck Typing‚Äôda obyektning turi emas, balki uning xatti-harakatlari (metodlari) muhim. Agar obyekt kerakli metodga ega bo‚Äòlsa, uni ishlatish mumkin:

```python
class Mushuk:
    def ovoz_chiqar(self):
        return "Miyov!"

class It:
    def ovoz_chiqar(self):
        return "Vov!"

class Robot:  # Hayvon sinfidan meros olmaydi
    def ovoz_chiqar(self):
        return "Beep-boop!"

def hayvon_ovozi(hayvon):
    print(hayvon.ovoz_chiqar())  # Faqat ovoz_chiqar metodining mavjudligini tekshiradi

mushuk = Mushuk()
it = It()
robot = Robot()
hayvon_ovozi(mushuk)  # Miyov!
hayvon_ovozi(it)  # Vov!
hayvon_ovozi(robot)  # Beep-boop!
```

Bu yerda `Robot` sinfi `Hayvon` sinfidan meros olmaydi, lekin `ovoz_chiqar` metodiga ega bo‚Äòlgani uchun `hayvon_ovozi` funksiyasi uni qabul qiladi.

### Duck Typing afzalliklari
- Kodni moslashuvchan qiladi.  
- Sinf ierarxiyasiga qattiq bog‚Äòlanishni talab qilmaydi.  
- Turli sinflar o‚Äòrtasida umumiy xatti-harakatni qo‚Äòllashni osonlashtiradi:

```python
class Kitob:
    def chop_et(self):
        return "Kitob chop etildi."

class Jurnal:
    def chop_et(self):
        return "Jurnal chop etildi."

def chop_qil(ob):
    print(ob.chop_et())

kitob = Kitob()
jurnal = Jurnal()
chop_qil(kitob)  # Kitob chop etildi.
chop_qil(jurnal)  # Jurnal chop etildi.
```

### Duck Typing bilan ehtiyotkorlik
Agar obyekt kerakli metodga ega bo‚Äòlmasa, xato yuzaga keladi:

```python
class Stol:
    def yoz(self):  # chop_et metodi yo‚Äòq
        return "Stol ustida yozildi."

stol = Stol()
chop_qil(stol)  # AttributeError: 'Stol' object has no attribute 'chop_et'
```

Bunday hollarda `hasattr` yordamida tekshirish mumkin:

```python
def chop_qil(ob):
    if hasattr(ob, "chop_et"):
        print(ob.chop_et())
    else:
        print("Bu obyekt chop etilmaydi.")

chop_qil(stol)  # Bu obyekt chop etilmaydi.
```

Mashq: Quyidagi vazifani bajaring:  
- `Shakl` nomli sinf yarating, u `chiz` metodiga ega bo‚Äòlsin.  
- `Rasm` nomli boshqa sinf yarating, u ham `chiz` metodiga ega bo‚Äòlsin.  
- `chizish` nomli funksiya yozing va Duck Typing yordamida ikkala obyektni sinab ko‚Äòring.  

5 daqiqa vaqt beraman!

---

## 3. Interface-based programming (20 daqiqa)

Ajoyib, endi **Interface-based programming** haqida gaplashamiz! Python‚Äôda to‚Äòg‚Äòridan-to‚Äòg‚Äòri interfeys yo‚Äòq, lekin abstract classlar orqali simulyatsiya qilinadi.

### Interface-based programming nima?
Interfeyslar umumiy xatti-harakatni aniqlaydi va turli sinflarga bu xatti-harakatni majburiy qiladi. Python‚Äôda bu `abc` moduli yordamida amalga oshiriladi:

```python
from abc import ABC, abstractmethod

class Printable(ABC):  # Interfeys sifatida ishlatiladi
    @abstractmethod
    def chop_et(self):
        pass

class Kitob(Printable):
    def chop_et(self):
        return "Kitob chop etildi."

class Jurnal(Printable):
    def chop_et(self):
        return "Jurnal chop etildi."

def chop_qil(ob):
    print(ob.chop_et())

kitob = Kitob()
jurnal = Jurnal()
chop_qil(kitob)  # Kitob chop etildi.
chop_qil(jurnal)  # Jurnal chop etildi.
```

Bu yerda `Printable` interfeys sifatida ishlatildi va `chop_et` metodini majburiy qildi.

### Duck Typing vs Interface-based
- **Duck Typing**: Obyektning faqat xatti-harakatlariga e‚Äôtibor beradi, sinf ierarxiyasi muhim emas.  
- **Interface-based**: Majburiy xatti-harakatni aniq belgilaydi va sinf ierarxiyasiga bog‚Äòliq:

```python
from abc import ABC, abstractmethod

class Harakatlanuvchi(ABC):
    @abstractmethod
    def harakatlan(self):
        pass

class Mashina(Harakatlanuvchi):
    def harakatlan(self):
        return "Mashina yo‚Äòlda yurmoqda..."

class Velosiped(Harakatlanuvchi):
    def harakatlan(self):
        return "Velosiped pedal bilan yurmoqda..."

def transport_harakat(transport):
    print(transport.harakatlan())

mashina = Mashina()
velosiped = Velosiped()
transport_harakat(mashina)  # Mashina yo‚Äòlda yurmoqda...
transport_harakat(velosiped)  # Velosiped pedal bilan yurmoqda...
```

### Bir nechta interfeys
Bir sinf bir nechta interfeysni qo‚Äòllashi mumkin:

```python
from abc import ABC, abstractmethod

class Yozuvchi(ABC):
    @abstractmethod
    def yoz(self):
        pass

class ChopEtuvchi(ABC):
    @abstractmethod
    def chop_et(self):
        pass

class Muallif(Yozuvchi, ChopEtuvchi):
    def yoz(self):
        return "Muallif yozmoqda..."

    def chop_et(self):
        return "Muallif chop etmoqda..."

muallif = Muallif()
print(muallif.yoz())  # Muallif yozmoqda...
print(muallif.chop_et())  # Muallif chop etmoqda...
```

Interface-based programming polimorfizmni yanada tartibli qiladi.

Mashq: Quyidagi vazifani bajaring:  
- `Yozuvchi` nomli interfeys yarating, u `yoz` metodiga ega bo‚Äòlsin.  
- `Muallif` nomli sinf yarating, u `yoz` metodini amalga oshirsin.  
- `yozish` nomli funksiya yozing va interfeys orqali sinab ko‚Äòring.  

5 daqiqa vaqt beraman!

---

## 4. Amaliy mashqlar (25 daqiqa)

Endi o‚Äòrganganlarimizni amalda sinab ko‚Äòramiz! Quyidagi mashqlarni qilamiz:

### Mashq 1: Duck Typing
- `Mushuk` nomli sinf yarating, u `ovoz_chiqar` metodiga ega bo‚Äòlsin.  
- `Robot` nomli sinf yarating, u ham `ovoz_chiqar` metodiga ega bo‚Äòlsin.  
- `ovoz_chiqarish` nomli funksiya yozing va Duck Typing yordamida ikkala obyektni sinab ko‚Äòring.

```python
class Mushuk:
    def ovoz_chiqar(self):
        return "Miyov!"

class Robot:
    def ovoz_chiqar(self):
        return "Beep-boop!"

def ovoz_chiqarish(ob):
    print(ob.ovoz_chiqar())

mushuk = Mushuk()
robot = Robot()
ovoz_chiqarish(mushuk)  # Miyov!
ovoz_chiqarish(robot)  # Beep-boop!
```

### Mashq 2: Interface-based programming
- `Harakatlanuvchi` nomli interfeys yarating, u `harakatlan` metodiga ega bo‚Äòlsin.  
- `Mashina` va `Qayiq` nomli sinflar yarating, ular `harakatlan` metodini amalga oshirsin.  
- `harakat` nomli funksiya yozing va interfeys orqali sinab ko‚Äòring.

```python
from abc import ABC, abstractmethod

class Harakatlanuvchi(ABC):
    @abstractmethod
    def harakatlan(self):
        pass

class Mashina(Harakatlanuvchi):
    def harakatlan(self):
        return "Mashina yo‚Äòlda yurmoqda..."

class Qayiq(Harakatlanuvchi):
    def harakatlan(self):
        return "Qayiq suvda suzmoqda..."

def harakat(ob):
    print(ob.harakatlan())

mashina = Mashina()
qayiq = Qayiq()
harakat(mashina)  # Mashina yo‚Äòlda yurmoqda...
harakat(qayiq)  # Qayiq suvda suzmoqda...
```

### Mashq 3: Duck Typing va Interface birgalikda
- `ChopEtuvchi` nomli interfeys yarating, u `chop_et` metodiga ega bo‚Äòlsin.  
- `Kitob` nomli sinf yarating, u `chop_et` metodini amalga oshirsin.  
- `Printer` nomli sinf yarating, u `chop_et` metodiga ega bo‚Äòlsin (lekin interfeysdan meros olmasin).  
- `chop_qilish` nomli funksiya yozing va ikkala obyektni sinab ko‚Äòring.

```python
from abc import ABC, abstractmethod

class ChopEtuvchi(ABC):
    @abstractmethod
    def chop_et(self):
        pass

class Kitob(ChopEtuvchi):
    def chop_et(self):
        return "Kitob chop etildi."

class Printer:
    def chop_et(self):
        return "Printer chop etmoqda..."

def chop_qilish(ob):
    print(ob.chop_et())

kitob = Kitob()
printer = Printer()
chop_qilish(kitob)  # Kitob chop etildi.
chop_qilish(printer)  # Printer chop etmoqda...
```

Har bir mashq uchun 8-9 daqiqa vaqt beraman. Kodlarni yozib, natijalarni ekranga chiqaring!

---

## 5. Xulosa va uy vazifasi (20 daqiqa)

Ajoyib, yosh dasturchilar! üéâ Bugun biz polimorfizmni chuqurlashtirdik: Duck Typing va Interface-based programming bilan ishladik. Duck Typing moslashuvchanlikni ta‚Äôminlasa, Interface-based programming tartib va aniqlik keltiradi.

Uyga vazifa sifatida quyidagini qiling:  
1. `Shakl` nomli sinf yarating, u `chiz` metodiga ega bo‚Äòlsin.  
   - `Doira` nomli sinf yarating, u ham `chiz` metodiga ega bo‚Äòlsin.  
   - `chizish` nomli funksiya yozing va Duck Typing yordamida sinab ko‚Äòring.  
2. `Yozuvchi` nomli interfeys yarating, u `yoz` metodiga ega bo‚Äòlsin.  
   - `Muallif` va `Jurnalist` nomli sinflar yarating, ular `yoz` metodini amalga oshirsin.  
   - `yozish` nomli funksiya yozing va interfeys orqali sinab ko‚Äòring.  
3. `ChopEtuvchi` nomli interfeys yarating, u `chop_et` metodiga ega bo‚Äòlsin.  
   - `Kitob` nomli sinf yarating, u `chop_et` metodini amalga oshirsin.  
   - `Robot` nomli sinf yarating, u `chop_et` metodiga ega bo‚Äòlsin (lekin interfeysdan meros olmasin).  
   - `chop_qilish` nomli funksiya yozing va ikkala obyektni sinab ko‚Äòring.

Darsimiz shu bilan tugadi, keyingi darsda esa `Dunder metodlar: __str__, __repr__, __getitem__, __setitem__,` va boshqalarni o‚Äòrganamiz. Savollaringiz bo‚Äòlsa, yozib qoldiring yoki keyingi darsda so‚Äòrang! üòä
---

## 6. Qayta ko'rib chiqish va savollar (10 daqiqa)

Zo‚Äòr ish qildingiz! Endi bir oz o'rganganlarimizi qayta ko'rib chiqamiz. Bugungi darsda nimalarni o‚Äòrgandik? Kim aytib bera oladi? (O‚Äòquvchilar javobini kutaman.)

- Duck Typing qanday ishlaydi?  
- Interface-based programming nima uchun muhim?  
- Duck Typing va Interface-based o‚Äòrtasidagi farq nima?  

Qandaydir tushunmovchilik bo‚Äòldimi? Savollaringiz bormi? (O‚Äòquvchilar savollarini eshitaman va tushuntiraman.) üòä

---