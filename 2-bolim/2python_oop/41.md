# üìö Darsning mavzusi: Dekoratorlar bilan ishlash: Class-based dekoratorlar

## Qisqacha vaqt taqsimoti

| Qism                          | Davomiyligi     |
|-------------------------------|-----------------|
| Kirish va Dekoratorlar qayta ko‚Äòrib chiqish | 20 daqiqa       |
| Class-based dekoratorlar yaratish | 25 daqiqa       |
| Amaliy misollar va murakkab dekoratorlar | 20 daqiqa       |
| Amaliy mashqlar               | 25 daqiqa       |
| Xulosa va uy vazifasi         | 20 daqiqa       |
| Qayta aloqa va savollar       | 10 daqiqa       |
| Jami                          | 120 daqiqa (2 soat) |

Bu usul yoshlar uchun samarali, qiziqarli va tushunarli bo‚Äòlib, o‚Äòquvchilarni dars jarayoniga faolroq jalb qiladi.

---

# üìñ Darsning batafsil rejasi

## 1. Kirish va Dekoratorlar qayta ko‚Äòrib chiqish (20 daqiqa)

Assalomu alaykum, yosh dasturchilar! üòä Bugun biz Python‚Äôda **Dekoratorlar**ni chuqurlashtiramiz va ayniqsa **Class-based dekoratorlar** bilan ishlashni o‚Äòrganamiz. Avvalgi darslarda oddiy funksiya dekoratorlari bilan tanishgan edik. Bugun esa sinf asosidagi dekoratorlarni yaratish va qo‚Äòllashni ko‚Äòramiz.

**Dekoratorlar nima edi?**  
Dekoratorlar ‚Äî bu funksiyalar yoki metodlarning xatti-harakatlarini o‚Äòzgartirish yoki kengaytirish uchun ishlatiladigan maxsus vositalar. Ular Python‚Äôda `@` belgisi bilan qo‚Äòllaniladi. Oddiy dekorator misoli:

```python
def salom_dekorator(func):
    def wrapper():
        print("Salom!")
        func()
    return wrapper

@salom_dekorator
def xayr():
    print("Xayr!")

xayr()
# Natija:
# Salom!
# Xayr!
```

Bugun biz sinf asosidagi dekoratorlarni o‚Äòrganamiz, ya‚Äôni dekorator sifatida sinf ishlatishni ko‚Äòramiz.

Keling, bir savol: Dekoratorlar qanday hollarda foydali deb o‚Äòylaysiz? (O‚Äòquvchilar javobini kutaman, to‚Äòg‚Äòri javob bo‚Äòlsa: ‚ÄúAjoyib, to‚Äòg‚Äòri!‚Äù deyman.)

Mashq: Quyidagi vazifani bajaring:  
- `log_dekorator` nomli oddiy dekorator yarating, u funksiyaning chaqirilganini log qilsin (masalan, "Funksiya chaqirildi").  
- `salom` nomli funksiya yarating va dekoratorni qo‚Äòllang.  
- Funksiyani chaqirib, natijani ekranga chiqaring.  

5 daqiqa vaqt beraman!

---

## 2. Class-based dekoratorlar yaratish (25 daqiqa)

Endi **Class-based dekoratorlar** bilan tanishamiz! Class-based dekoratorlar sinf sifatida yaratiladi va `__call__` maxsus metodidan foydalanadi.

### Class-based dekorator nima?
Class-based dekorator yaratish uchun sinf ichida `__call__` metodini aniqlaymiz. Bu metod sinf obyekti chaqirilganda ishlaydi. Oddiy misol:

```python
class SalomDekorator:
    def __init__(self, func):
        self.func = func

    def __call__(self):
        print("Salom!")
        self.func()

@SalomDekorator
def xayr():
    print("Xayr!")

xayr()
# Natija:
# Salom!
# Xayr!
```

Bu yerda:  
- `SalomDekorator` sinfi dekorator sifatida ishlatildi.  
- `__init__` metodi dekorator qo‚Äòllaniladigan funksiyani (`func`) saqlaydi.  
- `__call__` metodi funksiya chaqirilganda qo‚Äòshimcha logika qo‚Äòshadi.

### Argumentli funksiyalar uchun dekorator
Agar dekorator qo‚Äòllaniladigan funksiya argument qabul qilsa, `__call__` metodida `*args` va `**kwargs` dan foydalanamiz:

```python
class LogDekorator:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print(f"Funksiya {self.func.__name__} chaqirildi.")
        return self.func(*args, **kwargs)

@LogDekorator
def salomlash(ism):
    return f"Salom, {ism}!"

print(salomlash("Ali"))
# Natija:
# Funksiya salomlash chaqirildi.
# Salom, Ali!
```

### Class-based dekoratorning afzalliklari
- Sinf ichida holatni (state) saqlash mumkin (masalan, qancha marta chaqirilganini hisoblash).  
- Murakkab logikani sinf ichida tashkil qilish oson.  
- Kodni yanada tartibli qiladi.

Holatni saqlashga misol:

```python
class CounterDekorator:
    def __init__(self, func):
        self.func = func
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"Funksiya {self.count} marta chaqirildi.")
        return self.func(*args, **kwargs)

@CounterDekorator
def salom():
    print("Salom, dunyo!")

salom()
salom()
# Natija:
# Funksiya 1 marta chaqirildi.
# Salom, dunyo!
# Funksiya 2 marta chaqirildi.
# Salom, dunyo!
```

Mashq: Quyidagi vazifani bajaring:  
- `TimeDekorator` nomli class-based dekorator yarating, u funksiyaning bajarilish vaqtini log qilsin (`time` modulidan foydalaning).  
- `hisobla` nomli funksiya yarating (masalan, 1 dan 10000 gacha yig‚Äòindi hisoblasin) va dekoratorni qo‚Äòllang.  
- Funksiyani chaqirib, natijani ekranga chiqaring.  

5 daqiqa vaqt beraman!

---

## 3. Amaliy misollar va murakkab dekoratorlar (20 daqiqa)

Ajoyib, endi class-based dekoratorlarni yanada murakkab holatlarda qo‚Äòllaymiz!

### Dekoratorga parametr qo‚Äòshish
Class-based dekoratorlarga parametr qo‚Äòshish uchun qo‚Äòshimcha sinf qatlami kerak:

```python
class TekshiruvchiDekorator:
    def __init__(self, min_qiymat):
        self.min_qiymat = min_qiymat

    def __call__(self, func):
        def wrapper(x):
            if x < self.min_qiymat:
                print(f"Xato: {x} < {self.min_qiymat}")
                return None
            return func(x)
        return wrapper

@TekshiruvchiDekorator(min_qiymat=0)
def kvadrat(x):
    return x ** 2

print(kvadrat(5))  # 25
print(kvadrat(-3))  # Xato: -3 < 0
# None
```

Bu yerda `TekshiruvchiDekorator` parametri sifatida `min_qiymat` ni qabul qiladi va funksiyaga qo‚Äòllaniladi.

### Class metodlarida dekorator
Class-based dekoratorlarni sinf metodlariga ham qo‚Äòllash mumkin:

```python
class LogDekorator:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print(f"Metod {self.func.__name__} chaqirildi.")
        return self.func(*args, **kwargs)

class Shaxs:
    def __init__(self, ism):
        self.ism = ism

    @LogDekorator
    def salomlash(self):
        return f"Salom, men {self.ism}!"

shaxs = Shaxs("Ali")
print(shaxs.salomlash())
# Natija:
# Metod salomlash chaqirildi.
# Salom, men Ali!
```

### Class-based dekorator bilan getter/setter
`@property` kabi maxsus metodlarga dekorator qo‚Äòllash:

```python
class CheckDekorator:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print("Tekshiruv amalga oshirildi.")
        return self.func(*args, **kwargs)

class Talaba:
    def __init__(self, ism):
        self._ism = ism

    @property
    @CheckDekorator
    def ism(self):
        return self._ism

    @ism.setter
    @CheckDekorator
    def ism(self, yangi_ism):
        self._ism = yangi_ism

talaba = Talaba("Ali")
print(talaba.ism)  # Tekshiruv amalga oshirildi.
# Ali
talaba.ism = "Vali"  # Tekshiruv amalga oshirildi.
print(talaba.ism)  # Tekshiruv amalga oshirildi.
# Vali
```

Mashq: Quyidagi vazifani bajaring:  
- `AccessDekorator` nomli class-based dekorator yarating, u faqat ijobiy sonlarni qabul qilsin.  
- `hisobla_yigindi` nomli funksiya yarating, u ikki sonni qo‚Äòshsin va dekoratorni qo‚Äòllang.  
- Funksiyani turli qiymatlar bilan sinab ko‚Äòring.  

5 daqiqa vaqt beraman!

---

## 4. Amaliy mashqlar (25 daqiqa)

Endi o‚Äòrganganlarimizni amalda sinab ko‚Äòramiz! Quyidagi mashqlarni qilamiz:

### Mashq 1: Oddiy class-based dekorator
- `LogDekorator` nomli class-based dekorator yarating, u funksiyaning chaqirilganini log qilsin.  
- `salomlash` nomli funksiya yarating va dekoratorni qo‚Äòllang.  
- Funksiyani chaqirib, natijani ekranga chiqaring.

```python
class LogDekorator:
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        print(f"Funksiya {self.func.__name__} chaqirildi.")
        return self.func(*args, **kwargs)

@LogDekorator
def salomlash(ism):
    return f"Salom, {ism}!"

print(salomlash("Zilola"))
# Natija:
# Funksiya salomlash chaqirildi.
# Salom, Zilola!
```

### Mashq 2: Holatni saqlovchi dekorator
- `CounterDekorator` nomli class-based dekorator yarating, u funksiyaning necha marta chaqirilganini hisoblasin.  
- `hisobla` nomli funksiya yarating va dekoratorni qo‚Äòllang.  
- Funksiyani bir nechta marta chaqirib, natijani ekranga chiqaring.

```python
class CounterDekorator:
    def __init__(self, func):
        self.func = func
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"Funksiya {self.count} marta chaqirildi.")
        return self.func(*args, **kwargs)

@CounterDekorator
def hisobla():
    print("Hisoblash amalga oshirildi.")

hisobla()
hisobla()
# Natija:
# Funksiya 1 marta chaqirildi.
# Hisoblash amalga oshirildi.
# Funksiya 2 marta chaqirildi.
# Hisoblash amalga oshirildi.
```

### Mashq 3: Parametrli class-based dekorator
- `MinCheckDekorator` nomli class-based dekorator yarating, u faqat `min_qiymat` dan katta sonlarni qabul qilsin.  
- `kvadrat` nomli funksiya yarating, u sonning kvadratini hisoblasin va dekoratorni qo‚Äòllang.  
- Funksiyani turli qiymatlar bilan sinab ko‚Äòring.

```python
class MinCheckDekorator:
    def __init__(self, min_qiymat):
        self.min_qiymat = min_qiymat

    def __call__(self, func):
        def wrapper(x):
            if x < self.min_qiymat:
                print(f"Xato: {x} < {self.min_qiymat}")
                return None
            return func(x)
        return wrapper

@MinCheckDekorator(min_qiymat=0)
def kvadrat(x):
    return x ** 2

print(kvadrat(4))  # 16
print(kvadrat(-2))  # Xato: -2 < 0
# None
```

Har bir mashq uchun 8-9 daqiqa vaqt beraman. Kodlarni yozib, natijalarni ekranga chiqaring!

---

## 5. Xulosa va uy vazifasi (20 daqiqa)

Ajoyib, yosh dasturchilar! üéâ Bugun biz class-based dekoratorlarni o‚Äòrgandik. Ular funksiyalarni moslashtirishda juda foydali bo‚Äòlib, holatni saqlash va murakkab logikani tashkil qilish imkonini beradi.

Uyga vazifa sifatida quyidagini qiling:  
1. `LogDekorator` nomli class-based dekorator yarating, u funksiyaning argumentlari va natijasini log qilsin.  
   - `koptir` nomli funksiya yarating, u sonni 2 ga ko‚Äòpaytirsin va dekoratorni qo‚Äòllang.  
   - Funksiyani sinab ko‚Äòring.  
2. `RetryDekorator` nomli class-based dekorator yarating, u funksiyani xato yuz bersa 3 marta qayta chaqirsin (`try-except` ishlating).  
   - `bo‚Äòluv` nomli funksiya yarating, u ikki sonni bo‚Äòlsin va dekoratorni qo‚Äòllang.  
   - Funksiyani sinab ko‚Äòring (masalan, 0 ga bo‚Äòlish xatosini sinang).  
3. `LimitDekorator` nomli class-based dekorator yarating, u funksiyaning necha marta chaqirilishini cheklasin (masalan, 5 marta).  
   - `salom` nomli funksiya yarating va dekoratorni qo‚Äòllang.  
   - Funksiyani bir nechta marta chaqirib, natijani ko‚Äòring.

Darsimiz shu bilan tugadi, keyingi darsda esa `Datetime moduli: Sana va vaqt bilan ishlash` mavzusini o‚Äòrganamiz. Savollaringiz bo‚Äòlsa, yozib qoldiring yoki keyingi darsda so‚Äòrang! üòä

---

## 6. Qayta ko'rib chiqish va savollar (10 daqiqa)

Zo‚Äòr ish qildingiz! Endi bir oz o'rganganlarimizi qayta ko'rib chiqamiz. Bugungi darsda nimalarni o‚Äòrgandik? Kim aytib bera oladi? (O‚Äòquvchilar javobini kutaman.)

- Class-based dekoratorlar qanday ishlaydi?  
- `__call__` metodi nima uchun kerak?  
- Class-based dekoratorlar qayerda foydali bo‚Äòladi?  

Qandaydir tushunmovchilik bo‚Äòldimi? Savollaringiz bormi? (O‚Äòquvchilar savollarini eshitaman va tushuntiraman.) üòä

---
