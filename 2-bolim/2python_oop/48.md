# ğŸ“š Darsning mavzusi: Memory Management advanced

## Qisqacha vaqt taqsimoti

| Qism                          | Davomiyligi     |
|-------------------------------|-----------------|
| Kirish va avvalgi bilimlarni eslatish | 20 daqiqa       |
| Pythonâ€™da xotira boshqaruvi mexanizmlari | 25 daqiqa       |
| Murakkab holatlarda xotira optimizatsiyasi | 20 daqiqa       |
| Amaliy mashqlar               | 25 daqiqa       |
| Xulosa va uy vazifasi         | 20 daqiqa       |
| Qayta aloqa va savollar       | 10 daqiqa       |
| Jami                          | 120 daqiqa (2 soat) |

Bu usul yoshlar uchun samarali, qiziqarli va tushunarli boâ€˜lib, oâ€˜quvchilarni dars jarayoniga faolroq jalb qiladi.

---

# ğŸ“– Darsning batafsil rejasi

## 1. Kirish va avvalgi bilimlarni eslatish (20 daqiqa)

Assalomu alaykum, yosh dasturchilar! ğŸ˜Š Bugun biz xotira boshqaruvi (Memory Management) boâ€˜yicha chuqurroq bilimlarni oâ€˜rganamiz. Avvalgi darsimizda biz Reference Counting va Garbage Collection haqida umumiy tushunchaga ega boâ€˜lgan edik. Bugun esa bu mexanizmlarni chuqurroq tahlil qilamiz va murakkab holatlarda xotirani qanday optimizatsiya qilishni koâ€˜ramiz.

**Eslatma:** Xotira boshqaruvi dastur samaradorligini oshirish va xotira oqishi (memory leak) kabi muammolarni oldini olish uchun juda muhim. Bugun biz quyidagilarni oâ€˜rganamiz:  
- Garbage Collectionâ€™ning ichki mexanizmlari.  
- Tsiklik havolalarni aniqlash va bartaraf etish.  
- Xotira oqishini oldini olish uchun ilgâ€˜or usullar.  

Oddiy misol bilan boshlaymiz:

```python
import gc
import sys

# Tsiklik havola yaratish
a = []
b = []
a.append(b)
b.append(a)

print(sys.getrefcount(a))  # Havola sonini tekshirish
a = None
b = None
gc.collect()  # Garbage Collection ishga tushadi
print("Tsiklik havola tozalandi!")
```

Keling, bir savol: Reference Counting va Garbage Collection oâ€˜rtasidagi asosiy farq nima edi? (Oâ€˜quvchilar javobini kutaman, toâ€˜gâ€˜ri javob boâ€˜lsa: â€œAjoyib, toâ€˜gâ€˜ri!â€ deyman.)

Mashq: Quyidagi vazifani bajaring:  
- `sys` va `gc` modullarini import qiling.  
- `x = [1, 2, 3]` oâ€˜zgaruvchisini yarating va uning havola sonini tekshiring (`sys.getrefcount`).  
- `x = None` qilib, `gc.collect()` ni chaqiring va xotira boâ€˜shatilganini tasavvur qiling.  

5 daqiqa vaqt beraman!

---

## 2. Pythonâ€™da xotira boshqaruvi mexanizmlari (25 daqiqa)

Endi Pythonâ€™da xotira boshqaruvi mexanizmlarini chuqurroq oâ€˜rganamiz!

### Garbage Collectionâ€™ning ichki mexanizmi
Pythonâ€™da Garbage Collection (GC) tsiklik havolalarni aniqlash uchun ishlatiladi. GC obyektlarni avtomatik boâ€˜shatish uchun 3 avlod (generation) tizimidan foydalanadi:  
- **0-avlod:** Yangi obyektlar.  
- **1-avlod:** 0-avlod tekshiruvidan omon qolgan obyektlar.  
- **2-avlod:** 1-avlod tekshiruvidan omon qolgan obyektlar.  

GC qanchalik "keksa" avlod boâ€˜lsa, shunchalik kam tekshiradi:

```python
import gc

# GC avlodlarini koâ€˜rish
print(gc.get_threshold())  # (700, 10, 10) â€” standart sozlamalar

# 0-avlod 700 ta obyekt toâ€˜planganda tekshiriladi
# 1-avlod 0-avlod 10 marta tekshirilganda ishga tushadi
# 2-avlod 1-avlod 10 marta tekshirilganda ishga tushadi
```

### Tsiklik havolalarni aniqlash
Tsiklik havolalar Reference Counting bilan aniqlanmaydi. Masalan:

```python
import gc

class Node:
    def __init__(self, qiymat):
        self.qiymat = qiymat
        self.keyingi = None

# Tsiklik havola yaratish
a = Node(1)
b = Node(2)
a.keyingi = b
b.keyingi = a

a = None
b = None
gc.collect()
print("Tsiklik havola tozalandi!")
```

Bu yerda `Node` obyektlari oâ€˜zaro tsiklik havola yaratdi, lekin GC ularni aniqlab, xotirani boâ€˜shatdi.

### GC sozlamalarini oâ€˜zgartirish
GC sozlamalarini oâ€˜zgartirish orqali uning ishini optimizatsiya qilish mumkin:

```python
import gc

# GC sozlamalarini oâ€˜zgartirish
gc.set_threshold(1000, 15, 15)  # 0-avlod 1000 obyekt, 1 va 2-avlod 15 marta
print(gc.get_threshold())  # (1000, 15, 15)

# GC ni qoâ€˜lda ishga tushirish
gc.collect()
```

### Obyektlarning oâ€˜chirilishini kuzatish
`__del__` metodidan foydalanib, obyekt oâ€˜chirilganda nima boâ€˜lishini koâ€˜rish mumkin:

```python
import gc

class Test:
    def __init__(self, ism):
        self.ism = ism

    def __del__(self):
        print(f"{self.ism} obyekt oâ€˜chirildi!")

obj = Test("Obyekt1")
obj = None
gc.collect()
# Natija:
# Obyekt1 obyekt oâ€˜chirildi!
```

Mashq: Quyidagi vazifani bajaring:  
- `gc` modulini import qiling va joriy GC sozlamalarini ekranga chiqaring (`gc.get_threshold`).  
- GC sozlamalarini oâ€˜zgartiring (`gc.set_threshold(500, 5, 5)`) va yangi sozlamalarni ekranga chiqaring.  
- `__del__` metodiga ega sinf yarating va obyektni oâ€˜chirib, natijani koâ€˜ring.  

5 daqiqa vaqt beraman!

---

## 3. Murakkab holatlarda xotira optimizatsiyasi (20 daqiqa)

Ajoyib, endi murakkab holatlarda xotirani qanday optimizatsiya qilishni oâ€˜rganamiz!

### Xotira oqishini oldini olish
Xotira oqishi (memory leak) â€” bu dasturda keraksiz obyektlar xotirada qolib ketishi. Masalan, global oâ€˜zgaruvchilar yoki yopilmagan fayllar:

```python
# Xotira oqishi misoli
global_list = []

def add_data():
    for i in range(100000):
        global_list.append(i)

add_data()
# global_list xotirada qoladi, bu xotira oqishiga olib kelishi mumkin
del global_list  # Xotirani boâ€˜shatish
```

### Weak References (Zaif havolalar)
`weakref` moduli yordamida zaif havolalar yaratish xotira oqishini oldini olishga yordam beradi:

```python
import weakref

class Test:
    def __init__(self, ism):
        self.ism = ism

obj = Test("Obyekt2")
weak_ref = weakref.ref(obj)
print(weak_ref())  # Obyekt hali mavjud

obj = None
gc.collect()
print(weak_ref())  # None (obyekt oâ€˜chirildi)
```

### Xotira profiling (tahlil qilish)
`tracemalloc` moduli yordamida xotira sarfini tahlil qilish:

```python
import tracemalloc

tracemalloc.start()

# Katta maâ€™lumotlar bilan ishlash
data = [i for i in range(100000)]

# Xotira sarfini koâ€˜rish
snapshot = tracemalloc.take_snapshot()
top_stats = snapshot.statistics("lineno")
print("[Top 3 xotira sarfi]")
for stat in top_stats[:3]:
    print(stat)
```

**Natija (taxminiy):**  
```
[Top 3 xotira sarfi]
<kod_fayli>.py:5: size=3.8 MiB, count=100000, average=40 B
...
```

### Generatorlar va iteratsiyadan foydalanish
Katta roâ€˜yxatlar oâ€˜rniga generatorlardan foydalanish xotirani tejaydi:

```python
# Roâ€˜yxat oâ€˜rniga generator
def katta_royxat():
    for i in range(100000):
        yield i

gen = katta_royxat()
for i in range(5):
    print(next(gen))  # 0, 1, 2, 3, 4
```

Mashq: Quyidagi vazifani bajaring:  
- `weakref` moduli yordamida zaif havola yarating va obyekt oâ€˜chirilganda natijani koâ€˜ring.  
- `tracemalloc` bilan katta roâ€˜yxatning xotira sarfini tahlil qiling (`[0] * 10000`).  
- `range(10000)` yordamida generator yarating va birinchi 5 ta elementni ekranga chiqaring.  

5 daqiqa vaqt beraman!

---

## 4. Amaliy mashqlar (25 daqiqa)

Endi oâ€˜rganganlarimizni amalda sinab koâ€˜ramiz! Quyidagi mashqlarni qilamiz:

### Mashq 1: Zaif havolalar bilan ishlash
- `weakref` moduli yordamida sinf yarating va zaif havola yarating.  
- Obyektni oâ€˜chirib, zaif havola natijasini ekranga chiqaring.

```python
import weakref
import gc

class Test:
    def __init__(self, ism):
        self.ism = ism

obj = Test("Obyekt3")
weak_ref = weakref.ref(obj)
print(weak_ref())  # Obyekt hali mavjud
obj = None
gc.collect()
print(weak_ref())  # None
```

### Mashq 2: Xotira sarfini tahlil qilish
- `tracemalloc` yordamida katta roâ€˜yxatning xotira sarfini tahlil qiling.  
- Roâ€˜yxatni oâ€˜chirib, xotira boâ€˜shatilganini tasavvur qiling.

```python
import tracemalloc

tracemalloc.start()
data = [0] * 10000
snapshot = tracemalloc.take_snapshot()
top_stats = snapshot.statistics("lineno")
print("[Top 3 xotira sarfi]")
for stat in top_stats[:3]:
    print(stat)
del data
```

### Mashq 3: Generator bilan optimizatsiya
- `range(20000)` yordamida generator yarating.  
- Birinchi 10 ta elementni ekranga chiqaring.  
- Shu jarayonni roâ€˜yxat bilan takrorlang (`list(range(20000))`) va farqni tasavvur qiling.

```python
# Generator bilan
gen = (i for i in range(20000))
for i in range(10):
    print(next(gen))  # 0 dan 9 gacha

# Roâ€˜yxat bilan (xotira koâ€˜proq sarflanadi)
royxat = list(range(20000))
print(royxat[:10])  # 0 dan 9 gacha
del royxat
```

Har bir mashq uchun 8-9 daqiqa vaqt beraman. Kodlarni yozib, natijalarni ekranga chiqaring!

---

## 5. Xulosa va uy vazifasi (20 daqiqa)

Ajoyib, yosh dasturchilar! ğŸ‰ Bugun biz xotira boshqaruvi boâ€˜yicha ilgâ€˜or tushunchalarni oâ€˜rgandik. Garbage Collection mexanizmlari, zaif havolalar, xotira tahlili va optimizatsiya usullarini koâ€˜rdik.

Uyga vazifa sifatida quyidagini qiling:  
1. `__del__` metodiga ega sinf yarating, obyektni oâ€˜chirib, natijani ekranga chiqaring.  
2. `weakref` yordamida sinf yarating, zaif havola yarating va obyekt oâ€˜chirilganda natijani koâ€˜ring.  
3. `tracemalloc` yordamida `[0] * 20000` roâ€˜yxatning xotira sarfini tahlil qiling, soâ€˜ng roâ€˜yxatni oâ€˜chirib, `gc.collect()` ni chaqiring.  

Darsimiz shu bilan tugadi, keyingi darsda esa `Difference between SQL and NoSQL Databases` mavzusini oâ€˜rganamiz. Savollaringiz boâ€˜lsa, yozib qoldiring yoki keyingi darsda soâ€˜rang! ğŸ˜Š

---

## 6. Qayta ko'rib chiqish va savollar (10 daqiqa)

Zoâ€˜r ish qildingiz! Endi bir oz o'rganganlarimizi qayta ko'rib chiqamiz. Bugungi darsda nimalarni oâ€˜rgandik? Kim aytib bera oladi? (Oâ€˜quvchilar javobini kutaman.)

- Garbage Collection avlodlari qanday ishlaydi?  
- Zaif havolalar qanday foyda beradi?  
- Xotira oqishini qanday oldini olish mumkin?  

Qandaydir tushunmovchilik boâ€˜ldimi? Savollaringiz bormi? (Oâ€˜quvchilar savollarini eshitaman va tushuntiraman.) ğŸ˜Š

---