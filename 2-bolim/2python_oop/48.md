# 📚 Darsning mavzusi: Memory Management advanced

## Qisqacha vaqt taqsimoti

| Qism                          | Davomiyligi     |
|-------------------------------|-----------------|
| Kirish va avvalgi bilimlarni eslatish | 20 daqiqa       |
| Python’da xotira boshqaruvi mexanizmlari | 25 daqiqa       |
| Murakkab holatlarda xotira optimizatsiyasi | 20 daqiqa       |
| Amaliy mashqlar               | 25 daqiqa       |
| Xulosa va uy vazifasi         | 20 daqiqa       |
| Qayta aloqa va savollar       | 10 daqiqa       |
| Jami                          | 120 daqiqa (2 soat) |

Bu usul yoshlar uchun samarali, qiziqarli va tushunarli bo‘lib, o‘quvchilarni dars jarayoniga faolroq jalb qiladi.

---

# 📖 Darsning batafsil rejasi

## 1. Kirish va avvalgi bilimlarni eslatish (20 daqiqa)

Assalomu alaykum, yosh dasturchilar! 😊 Bugun biz xotira boshqaruvi (Memory Management) bo‘yicha chuqurroq bilimlarni o‘rganamiz. Avvalgi darsimizda biz Reference Counting va Garbage Collection haqida umumiy tushunchaga ega bo‘lgan edik. Bugun esa bu mexanizmlarni chuqurroq tahlil qilamiz va murakkab holatlarda xotirani qanday optimizatsiya qilishni ko‘ramiz.

**Eslatma:** Xotira boshqaruvi dastur samaradorligini oshirish va xotira oqishi (memory leak) kabi muammolarni oldini olish uchun juda muhim. Bugun biz quyidagilarni o‘rganamiz:  
- Garbage Collection’ning ichki mexanizmlari.  
- Tsiklik havolalarni aniqlash va bartaraf etish.  
- Xotira oqishini oldini olish uchun ilg‘or usullar.  

Oddiy misol bilan boshlaymiz:

```python
import gc
import sys

# Tsiklik havola yaratish
a = []
b = []
a.append(b)
b.append(a)

print(sys.getrefcount(a))  # Havola sonini tekshirish
a = None
b = None
gc.collect()  # Garbage Collection ishga tushadi
print("Tsiklik havola tozalandi!")
```

Keling, bir savol: Reference Counting va Garbage Collection o‘rtasidagi asosiy farq nima edi? (O‘quvchilar javobini kutaman, to‘g‘ri javob bo‘lsa: “Ajoyib, to‘g‘ri!” deyman.)

Mashq: Quyidagi vazifani bajaring:  
- `sys` va `gc` modullarini import qiling.  
- `x = [1, 2, 3]` o‘zgaruvchisini yarating va uning havola sonini tekshiring (`sys.getrefcount`).  
- `x = None` qilib, `gc.collect()` ni chaqiring va xotira bo‘shatilganini tasavvur qiling.  

5 daqiqa vaqt beraman!

---

## 2. Python’da xotira boshqaruvi mexanizmlari (25 daqiqa)

Endi Python’da xotira boshqaruvi mexanizmlarini chuqurroq o‘rganamiz!

### Garbage Collection’ning ichki mexanizmi
Python’da Garbage Collection (GC) tsiklik havolalarni aniqlash uchun ishlatiladi. GC obyektlarni avtomatik bo‘shatish uchun 3 avlod (generation) tizimidan foydalanadi:  
- **0-avlod:** Yangi obyektlar.  
- **1-avlod:** 0-avlod tekshiruvidan omon qolgan obyektlar.  
- **2-avlod:** 1-avlod tekshiruvidan omon qolgan obyektlar.  

GC qanchalik "keksa" avlod bo‘lsa, shunchalik kam tekshiradi:

```python
import gc

# GC avlodlarini ko‘rish
print(gc.get_threshold())  # (700, 10, 10) — standart sozlamalar

# 0-avlod 700 ta obyekt to‘planganda tekshiriladi
# 1-avlod 0-avlod 10 marta tekshirilganda ishga tushadi
# 2-avlod 1-avlod 10 marta tekshirilganda ishga tushadi
```

### Tsiklik havolalarni aniqlash
Tsiklik havolalar Reference Counting bilan aniqlanmaydi. Masalan:

```python
import gc

class Node:
    def __init__(self, qiymat):
        self.qiymat = qiymat
        self.keyingi = None

# Tsiklik havola yaratish
a = Node(1)
b = Node(2)
a.keyingi = b
b.keyingi = a

a = None
b = None
gc.collect()
print("Tsiklik havola tozalandi!")
```

Bu yerda `Node` obyektlari o‘zaro tsiklik havola yaratdi, lekin GC ularni aniqlab, xotirani bo‘shatdi.

### GC sozlamalarini o‘zgartirish
GC sozlamalarini o‘zgartirish orqali uning ishini optimizatsiya qilish mumkin:

```python
import gc

# GC sozlamalarini o‘zgartirish
gc.set_threshold(1000, 15, 15)  # 0-avlod 1000 obyekt, 1 va 2-avlod 15 marta
print(gc.get_threshold())  # (1000, 15, 15)

# GC ni qo‘lda ishga tushirish
gc.collect()
```

### Obyektlarning o‘chirilishini kuzatish
`__del__` metodidan foydalanib, obyekt o‘chirilganda nima bo‘lishini ko‘rish mumkin:

```python
import gc

class Test:
    def __init__(self, ism):
        self.ism = ism

    def __del__(self):
        print(f"{self.ism} obyekt o‘chirildi!")

obj = Test("Obyekt1")
obj = None
gc.collect()
# Natija:
# Obyekt1 obyekt o‘chirildi!
```

Mashq: Quyidagi vazifani bajaring:  
- `gc` modulini import qiling va joriy GC sozlamalarini ekranga chiqaring (`gc.get_threshold`).  
- GC sozlamalarini o‘zgartiring (`gc.set_threshold(500, 5, 5)`) va yangi sozlamalarni ekranga chiqaring.  
- `__del__` metodiga ega sinf yarating va obyektni o‘chirib, natijani ko‘ring.  

5 daqiqa vaqt beraman!

---

## 3. Murakkab holatlarda xotira optimizatsiyasi (20 daqiqa)

Ajoyib, endi murakkab holatlarda xotirani qanday optimizatsiya qilishni o‘rganamiz!

### Xotira oqishini oldini olish
Xotira oqishi (memory leak) — bu dasturda keraksiz obyektlar xotirada qolib ketishi. Masalan, global o‘zgaruvchilar yoki yopilmagan fayllar:

```python
# Xotira oqishi misoli
global_list = []

def add_data():
    for i in range(100000):
        global_list.append(i)

add_data()
# global_list xotirada qoladi, bu xotira oqishiga olib kelishi mumkin
del global_list  # Xotirani bo‘shatish
```

### Weak References (Zaif havolalar)
`weakref` moduli yordamida zaif havolalar yaratish xotira oqishini oldini olishga yordam beradi:

```python
import weakref

class Test:
    def __init__(self, ism):
        self.ism = ism

obj = Test("Obyekt2")
weak_ref = weakref.ref(obj)
print(weak_ref())  # Obyekt hali mavjud

obj = None
gc.collect()
print(weak_ref())  # None (obyekt o‘chirildi)
```

### Xotira profiling (tahlil qilish)
`tracemalloc` moduli yordamida xotira sarfini tahlil qilish:

```python
import tracemalloc

tracemalloc.start()

# Katta ma’lumotlar bilan ishlash
data = [i for i in range(100000)]

# Xotira sarfini ko‘rish
snapshot = tracemalloc.take_snapshot()
top_stats = snapshot.statistics("lineno")
print("[Top 3 xotira sarfi]")
for stat in top_stats[:3]:
    print(stat)
```

**Natija (taxminiy):**  
```
[Top 3 xotira sarfi]
<kod_fayli>.py:5: size=3.8 MiB, count=100000, average=40 B
...
```

### Generatorlar va iteratsiyadan foydalanish
Katta ro‘yxatlar o‘rniga generatorlardan foydalanish xotirani tejaydi:

```python
# Ro‘yxat o‘rniga generator
def katta_royxat():
    for i in range(100000):
        yield i

gen = katta_royxat()
for i in range(5):
    print(next(gen))  # 0, 1, 2, 3, 4
```

Mashq: Quyidagi vazifani bajaring:  
- `weakref` moduli yordamida zaif havola yarating va obyekt o‘chirilganda natijani ko‘ring.  
- `tracemalloc` bilan katta ro‘yxatning xotira sarfini tahlil qiling (`[0] * 10000`).  
- `range(10000)` yordamida generator yarating va birinchi 5 ta elementni ekranga chiqaring.  

5 daqiqa vaqt beraman!

---

## 4. Amaliy mashqlar (25 daqiqa)

Endi o‘rganganlarimizni amalda sinab ko‘ramiz! Quyidagi mashqlarni qilamiz:

### Mashq 1: Zaif havolalar bilan ishlash
- `weakref` moduli yordamida sinf yarating va zaif havola yarating.  
- Obyektni o‘chirib, zaif havola natijasini ekranga chiqaring.

```python
import weakref
import gc

class Test:
    def __init__(self, ism):
        self.ism = ism

obj = Test("Obyekt3")
weak_ref = weakref.ref(obj)
print(weak_ref())  # Obyekt hali mavjud
obj = None
gc.collect()
print(weak_ref())  # None
```

### Mashq 2: Xotira sarfini tahlil qilish
- `tracemalloc` yordamida katta ro‘yxatning xotira sarfini tahlil qiling.  
- Ro‘yxatni o‘chirib, xotira bo‘shatilganini tasavvur qiling.

```python
import tracemalloc

tracemalloc.start()
data = [0] * 10000
snapshot = tracemalloc.take_snapshot()
top_stats = snapshot.statistics("lineno")
print("[Top 3 xotira sarfi]")
for stat in top_stats[:3]:
    print(stat)
del data
```

### Mashq 3: Generator bilan optimizatsiya
- `range(20000)` yordamida generator yarating.  
- Birinchi 10 ta elementni ekranga chiqaring.  
- Shu jarayonni ro‘yxat bilan takrorlang (`list(range(20000))`) va farqni tasavvur qiling.

```python
# Generator bilan
gen = (i for i in range(20000))
for i in range(10):
    print(next(gen))  # 0 dan 9 gacha

# Ro‘yxat bilan (xotira ko‘proq sarflanadi)
royxat = list(range(20000))
print(royxat[:10])  # 0 dan 9 gacha
del royxat
```

Har bir mashq uchun 8-9 daqiqa vaqt beraman. Kodlarni yozib, natijalarni ekranga chiqaring!

---

## 5. Xulosa va uy vazifasi (20 daqiqa)

Ajoyib, yosh dasturchilar! 🎉 Bugun biz xotira boshqaruvi bo‘yicha ilg‘or tushunchalarni o‘rgandik. Garbage Collection mexanizmlari, zaif havolalar, xotira tahlili va optimizatsiya usullarini ko‘rdik.

Uyga vazifa sifatida quyidagini qiling:  
1. `__del__` metodiga ega sinf yarating, obyektni o‘chirib, natijani ekranga chiqaring.  
2. `weakref` yordamida sinf yarating, zaif havola yarating va obyekt o‘chirilganda natijani ko‘ring.  
3. `tracemalloc` yordamida `[0] * 20000` ro‘yxatning xotira sarfini tahlil qiling, so‘ng ro‘yxatni o‘chirib, `gc.collect()` ni chaqiring.  

Darsimiz shu bilan tugadi, keyingi darsda esa `Difference between SQL and NoSQL Databases` mavzusini o‘rganamiz. Savollaringiz bo‘lsa, yozib qoldiring yoki keyingi darsda so‘rang! 😊

---

## 6. Qayta ko'rib chiqish va savollar (10 daqiqa)

Zo‘r ish qildingiz! Endi bir oz o'rganganlarimizi qayta ko'rib chiqamiz. Bugungi darsda nimalarni o‘rgandik? Kim aytib bera oladi? (O‘quvchilar javobini kutaman.)

- Garbage Collection avlodlari qanday ishlaydi?  
- Zaif havolalar qanday foyda beradi?  
- Xotira oqishini qanday oldini olish mumkin?  

Qandaydir tushunmovchilik bo‘ldimi? Savollaringiz bormi? (O‘quvchilar savollarini eshitaman va tushuntiraman.) 😊

---